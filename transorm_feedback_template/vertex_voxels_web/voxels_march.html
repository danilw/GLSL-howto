<!doctypehtml><html lang=en-us><head><meta charset=utf-8><meta content="text/html; charset=utf-8"http-equiv=Content-Type><title>Transform feedback shader</title><style>body,html{width:100%;height:100%;margin:0;padding:0;overflow:hidden;background-color:#303030}.emscripten_grid_container{display:grid;grid-template-columns:auto auto;padding:1px;width:8%;height:4%;position:absolute;border:0 none;background-color:#00000066;font-family:monospace;color:#fff}.emscripten_grid_item{background-color:rgba(10,15,20,.8);border:1px solid rgba(0,0,0,.8);font-family:monospace;color:#fff;padding:2px;font-size:12px;text-align:center}.emscripten{padding-right:0;margin-left:auto;margin-right:auto;display:block}textarea.emscripten{width:50%;height:15%;position:absolute;border:0 none;background-color:#00000066;font-family:monospace;color:#fff}div.emscripten{text-align:center}div.emscripten_border{border:0 solid #000}canvas.emscripten{top:calc(50vh - (100% / 2));left:calc(50vw - (100% / 2));position:absolute;width:100%;height:100%;border:0 none;background-color:#000}div.fullscreenDiv{background-color:#303030;width:100%;height:auto;bottom:0;top:0;left:0;position:absolute}div.loader{position:absolute;top:50%;left:50%;margin-top:-25px;color:#fff;margin-left:-100px}progress[value]{-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;width:250px;height:20px;background-color:#fff}.spinner{width:35px;display:inline-block;background-color:#fcfefd;margin:0 auto;height:35px;-webkit-animation:3s rotate2 ease-in-out infinite;animation:3s flip ease-in-out infinite}@-webkit-keyframes flip{0%{-webkit-transform:perspective(120px) rotateX(0) rotateY(0);transform:perspective(120px) rotateX(0) rotateY(0)}25%{-webkit-transform:perspective(120px) rotateX(-180deg) rotateY(0);transform:perspective(120px) rotateX(-180deg) rotateY(0)}50%{transform:perspective(120px) rotateX(-180deg) rotateY(-180deg);-webkit-transform:perspective(120px) rotateX(-180deg) rotateY(-180deg)}75%{-webkit-transform:perspective(120px) rotateX(0) rotateY(-180deg);transform:perspective(120px) rotateX(0) rotateY(-180deg)}100%{-webkit-transform:perspective(120px) rotateX(0) rotateY(-360deg);transform:perspective(120px) rotateX(0) rotateY(-360deg)}}@keyframes flip{0%{-webkit-transform:perspective(120px) rotateX(0) rotateY(0);transform:perspective(120px) rotateX(0) rotateY(0)}25%{-webkit-transform:perspective(120px) rotateX(-180deg) rotateY(0);transform:perspective(120px) rotateX(-180deg) rotateY(0)}50%{transform:perspective(120px) rotateX(-180deg) rotateY(-180deg);-webkit-transform:perspective(120px) rotateX(-180deg) rotateY(-180deg)}75%{-webkit-transform:perspective(120px) rotateX(0) rotateY(-180deg);transform:perspective(120px) rotateX(0) rotateY(-180deg)}100%{-webkit-transform:perspective(120px) rotateX(0) rotateY(-360deg);transform:perspective(120px) rotateX(0) rotateY(-360deg)}}</style><script id=shader-feedback type=glsl>#version 300 es
  precision highp float;
  precision highp int;
  #define vertexId float(gl_InstanceID+gl_VertexID)
  in vec4 feedback_data_1;
  in vec4 feedback_data_2;

  out vec4 feedback_data_1_out;
  out vec4 feedback_data_2_out;

  uniform vec4 uniform_feedback1;
  uniform vec4 uniform_feedback2;
  uniform vec4 uniform_feedback3;
  
  uniform vec2 mouse;
  uniform float time;
  uniform vec2 resolution;

  void main() {
      feedback_data_1_out=feedback_data_1;
      feedback_data_2_out=feedback_data_2;
      gl_Position = vec4 (0.0, 0.0, 0.0, 0.0);
      }</script><script id=shader-vertex type=glsl>#version 300 es
  precision highp float;
  precision highp int;
  #define vertexCount (uniform_custom3.x)
  #define vertexId float(gl_VertexID)

  in vec4 feedback_data_1;
  in vec4 feedback_data_2;

  uniform vec2 mouse;
  uniform float time;
  uniform vec2 resolution;

  uniform vec4 uniform_custom1;
  uniform vec4 uniform_custom2;
  uniform vec4 uniform_custom3;

  out vec4 v_color;

  const float PI = 3.1415926535898;

  const float VertX = 15.0;
  const float VertY = 15.0;

  const float tscale = 0.2;
  const vec3 obj_pos = vec3(-1.5);

  mat3 rotx(float a){float s = sin(a);float c = cos(a);return mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, c, s), vec3(0.0, -s, c));  }
  mat3 roty(float a){float s = sin(a);float c = cos(a);return mat3(vec3(c, 0.0, s), vec3(0.0, 1.0, 0.0), vec3(-s, 0.0, c));}
  mat3 rotz(float a){float s = sin(a);float c = cos(a);return mat3(vec3(c, s, 0.0), vec3(-s, c, 0.0), vec3(0.0, 0.0, 1.0 ));}


  const float degree_to_rad = PI / 180.0;

  mat4 perspectiveMatrix(float fovYInRad, float aspectRatio)
  {
      float yScale = 1.0 / tan(fovYInRad / 2.0);
      float xScale = yScale / aspectRatio;
      float zf = 100.0;
      float zn = 0.3;

      float z1 = zf / (zf - zn);
      float z2 = -zn * zf / (zf - zn);

      mat4 result = mat4(xScale, 0.0, 0.0, 0.0, 0.0, yScale, 0.0, 0.0, 0.0, 0.0, -z1, -1., 0.0, 0.0, z2, 0.0);

      return result;
  }

  mat4 lookat(vec3 eye, vec3 look, vec3 up)
  {
      vec3 z = normalize(eye - look);
      vec3 x = normalize(cross(up, z));
      vec3 y = cross(z, x);
      return mat4(x.x, y.x, z.x, 0.0, x.y, y.y, z.y, 0.0, x.z, y.z, z.z, 0.0, 0.0, 0.0, 0.0, 1.0) *
             mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, -eye.x, -eye.y, -eye.z, 1.0);
  }

  vec3 voxelPosToWorld(vec3 vp)
  {
      return vp * (tscale / (uniform_custom1.x)) + obj_pos;
  }

  float sphereSDF(vec3 p, float r)
  {
      return length(p) - r;
  }

  float sdBox( vec3 p, vec3 b )
  {
    vec3 q = abs(p) - b;
    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
  }

  float sdfUnion( const float a, const float b )
  {
      return min(a, b);
  }

  float sdfDifference( const float a, const float b)
  {
      return max(a, -b);
  }

  float sdfIntersection( const float a, const float b )
  {
      return max(a, b);
  }

  float scene(vec3 p)
  {
      float d = 0.0;
      float timer = -0.6 + 0.6 * sin(time);
      float d1 = 0.0;
      float d2 = 0.0;
      if(uniform_custom1.y<0.5)d1=sphereSDF(p + uniform_custom2.xyz, uniform_custom2.w);
        else d1=sdBox(p + uniform_custom2.xyz, vec3(uniform_custom2.w));
      if(uniform_custom1.z<0.5)d2=sphereSDF(p + vec3(0., timer, 0.), uniform_custom3.w);
        else d2=sdBox(p + vec3(0., timer, 0.), vec3(uniform_custom3.w));
      if(uniform_custom1.w<0.5)d = sdfDifference(d1,d2);
        else if(uniform_custom1.w<1.5)d = sdfIntersection(d1,d2);
          else d = sdfUnion(d1,d2);

      return d;
  }

  vec3 sceneNormal(vec3 p)
  {
      vec3 e = vec3(0.05, 0.0, 0.0);
      vec3 n;
      n.x = scene(p + e.xyz) - scene(p - e.xyz);
      n.y = scene(p + e.zxy) - scene(p - e.zxy);
      n.z = scene(p + e.yzx) - scene(p - e.yzx);
      return normalize(n);
  }

  vec3 vertexSmooth(vec3 ip)
  {
      vec3 p = ip;
      vec3 n = sceneNormal(p);
      for (int i = 0; i < 8; i++)
      {
          float d = scene(p);
          p -= n * d;
          if (abs(d) < 0.01)
          {
              break;
          }
      }
      return p;
  }

  vec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, vec3 lightPos, vec3 lightIntensity, vec3 N)
  {
      vec3 L = normalize(lightPos - p);
      vec3 V = normalize(eye - p);
      vec3 R = normalize(reflect(-L, N));

      float dotLN = dot(L, N);
      float dotRV = dot(R, V);

      if (dotLN < 0.0)
      {
          return vec3(0.0, 0.0, 0.0);
      }

      if (dotRV < 0.0)
      {
          return lightIntensity * (k_d * dotLN);
      }
      return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));
  }

  vec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, vec3 norm)
  {
      const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);
      vec3 color = ambientLight * k_a;

      vec3 light1Pos = normalize(vec3(mouse.x, mouse.y, .20));
      vec3 light1Intensity = 2. * vec3(0.4, 0.4, 0.4);

      color += phongContribForLight(k_d, k_s, alpha, p, eye, light1Pos, light1Intensity, norm);

      return color;
  }

  vec4 color_phong(vec3 p, vec3 ro, vec3 n, vec3 col)
  {
      vec3 K_a = col;
      vec3 K_d = K_a;
      vec3 K_s = vec3(1.0, 1.0, 1.0);
      float shininess = 12.0;

      col = phongIllumination(K_a, K_d, K_s, shininess, p, ro, n);
      return vec4(col, 1.);
  }

  void main()
  {
      // vertex index in quad face, two triangles
      float id_Vert = mod(vertexId, 6.0);
      // face index
      float id_Face = floor(vertexId / 6.0);
      // corner face index
      float id_Face_corner = mod(id_Face, 3.0);
      // corner edge index
      float id_Edge = mod(id_Face, 3.0);
      // corner index 1 corner is 3 faces is 3*6 verts
      float id_Corner = floor(vertexId / 18.0);
      // corner position
      vec3 cornerP;
      float tVertX = VertX * uniform_custom1.x;
      float tVertY = VertY * uniform_custom1.x;
      cornerP.x = mod(id_Corner, tVertX);
      cornerP.y = mod(floor(id_Corner / tVertX), tVertY);
      cornerP.z = mod(floor(id_Corner / (tVertX * tVertY)), tVertY);

      vec3 faceNorm;
      vec3 faceTan;
      vec3 faceaTan;
      if (id_Edge == 0.0)
      {
          faceNorm = vec3(1.0, 0.0, 0.0);
          faceTan = vec3(0.0, 0.0, -1.0);
          faceaTan = vec3(0.0, 1.0, 0.0);
      }
      else if (id_Edge == 1.0)
      {
          faceNorm = vec3(0.0, 1.0, 0.0);
          faceTan = vec3(1.0, 0.0, 0.0);
          faceaTan = vec3(0.0, 0.0, -1.0);
      }
      else
      {
          faceNorm = vec3(0.0, 0.0, 1.0);
          faceTan = vec3(1.0, 0.0, 0.0);
          faceaTan = vec3(0.0, 1.0, 0.0);
      }
      vec3 aPos = cornerP + faceNorm;

      // sampling points
      vec3 p0 = voxelPosToWorld(cornerP);
      vec3 p1 = voxelPosToWorld(aPos);

      // field value
      float d0 = scene(p0);
      float d1 = scene(p1);

      vec3 p;
      vec3 vertNorm;

      if (d0 * d1 > 0.0)
      {
          // no face
          p = p0;
          vertNorm = vec3(1.0, 1.0, 1.0);
      }
      else
      {
          // have a face
          if (d1 < d0)
          {
              // 0->1 is standard normal.
              // otherwise flip triangle
              if (id_Vert == 0.0)
              {
                  id_Vert = 2.0;
              }
              else if (id_Vert == 2.0)
              {
                  id_Vert = 0.0;
              }
              else if (id_Vert == 3.0)
              {
                  id_Vert = 5.0;
              }
              else if (id_Vert == 5.0)
              {
                  id_Vert = 3.0;
              }
              faceNorm *= -1.0;
          }

          /*
          face
          2 4-5
          |\ \|
          0-1 3
          */
          float faceSize = mix(0.45, 0.5, clamp(cos(time * .75) * 4.0 + 0.5, 0.0, 1.0));
          vec3 edgeMidP = (cornerP + aPos) * 0.5;
          vec3 faceVertP;
          if (id_Vert == 0.0)
          {
              faceVertP = edgeMidP + faceTan * -faceSize + faceaTan * -faceSize;
          }
          else if (id_Vert == 1.0)
          {
              faceVertP = edgeMidP + faceTan * faceSize + faceaTan * -faceSize;
          }
          else if (id_Vert == 2.0)
          {
              faceVertP = edgeMidP + faceTan * -faceSize + faceaTan * faceSize;
          }
          else if (id_Vert == 3.0)
          {
              faceVertP = edgeMidP + faceTan * faceSize + faceaTan * -faceSize;
          }
          else if (id_Vert == 4.0)
          {
              faceVertP = edgeMidP + faceTan * -faceSize + faceaTan * faceSize;
          }
          else if (id_Vert == 5.0)
          {
              faceVertP = edgeMidP + faceTan * 0.5 + faceaTan * 0.5;
          }
          p = voxelPosToWorld(faceVertP);

          // smoothing
          vec3 sp = vertexSmooth(p);
          vertNorm = sceneNormal(p);

          float vmix = clamp(sin(time * 0.35) * 2.0 + 0.5, 0.0, 1.0);
          vmix = 1.;
          p = mix(p, sp, vmix);
          vertNorm = mix(faceNorm, vertNorm, vmix);
      }

      vec3 eye = vec3(0.0, 0.0, 3.5) * rotx(clamp(mouse.y, -0.5, 0.5) * 2.5) * roty(-clamp(mouse.x, -0.5, 0.5) * 2.5);
      // eye = vec3(0.0, 0.0, 3.0);
      mat4 viewMat = lookat(eye, vec3(0.0), vec3(0.0, 1.0, 0.0));
      mat4 pMatrix = perspectiveMatrix(60.0 * degree_to_rad, resolution.x / resolution.y);
      vec4 viewPos = (viewMat * vec4(p, 1.0));
      vec3 viewNorm = normalize((viewMat * vec4(vertNorm, 0.0)).xyz);

      gl_Position = (pMatrix * viewPos) * 100.2;
      gl_PointSize = 2.0;

      v_color = color_phong(viewPos.xyz, eye, viewNorm, 0.5 * (viewNorm + 1.) / 2.);
  }</script></head><body><div class=emscripten_border><canvas class=emscripten id=canvas oncontextmenu=event.preventDefault()></canvas></div><textarea class=emscripten id=output rows=8></textarea><div class=emscripten_grid_container><div class=emscripten_grid_item>Render mode:</div><select class=emscripten_grid_item id=render onchange=set_render.call(this,event)><option value=triangles>Triangles</option><option value=lines>Lines</option><option value=points>Points</option></select><div class=emscripten_grid_item>Quality:</div><select class=emscripten_grid_item id=quality onchange=set_quality.call(this,event)><option value=q1>1</option><option value=q2>2</option><option value=q3>3</option></select><div class=emscripten_grid_item>SDF 1:</div><select class=emscripten_grid_item id=sdf1 onchange=set_sdf1.call(this,event)><option value=sphere>sphere</option><option value=cube>cube</option></select><div class=emscripten_grid_item>SDF 2:</div><select class=emscripten_grid_item id=sdf2 onchange=set_sdf2.call(this,event)><option value=sphere>sphere</option><option value=cube>cube</option></select><div class=emscripten_grid_item>SDF OP</div><select class=emscripten_grid_item id=sdfop onchange=set_sdfop.call(this,event)><option value=dif>Difference</option><option value=int>Intersection</option><option value=uni>Union</option></select><div class=emscripten_grid_item>SDF 1 radius:</div><input class=emscripten_grid_item max=200 min=1 onchange=set_sdf1r(this.value) type=range value=80><div class=emscripten_grid_item>SDF 2 radius:</div><input class=emscripten_grid_item max=200 min=1 onchange=set_sdf2r(this.value) type=range value=70><div class=emscripten_grid_item>SDF 1 posX:</div><input class=emscripten_grid_item max=100 min=1 onchange=set_sdf1x(this.value) type=range value=50><div class=emscripten_grid_item>SDF 1 posY:</div><input class=emscripten_grid_item max=100 min=1 onchange=set_sdf1y(this.value) type=range value=50><div class=emscripten_grid_item>SDF 1 posZ:</div><input class=emscripten_grid_item max=100 min=1 onchange=set_sdf1z(this.value) type=range value=50></div><div class=fullscreenDiv id=imloader><div class=loader><figure id=spinner style=overflow:visible><div class=spinner></div><center style=display:inline-block;margin-top:.5em><strong><font size=6>LOADING...</font></strong></center><div class=spinner></div></figure><div class=emscripten id=status>Downloading...</div><div class=emscripten><progress id=progress max=100 style=visibility:visible value=50></progress></div></div></div><script>var canvas=document.getElementById("canvas");document.getElementById("output").style.display="none";var NUM_PARTICLES=6e4,render_mode=0,quality=1,sdf1=0,sdf2=0,sdfop=0,sdf1_r=.8,sdf2_r=.65,sdf1_pos_x=0,sdf1_pos_y=0,sdf1_pos_z=0;function update_sdf1(){Module.cwrap("set_custom_uniform","number",["number","number","number","number"])(1,sdf1_pos_x,sdf1_pos_y,sdf1_pos_z,sdf1_r)}function update_sdf2(){Module.cwrap("set_custom_uniform","number",["number","number","number","number"])(2,NUM_PARTICLES,0,0,sdf2_r)}function update_conf(){Module.cwrap("set_custom_uniform","number",["number","number","number","number"])(0,quality,sdf1,sdf2,sdfop)}function fullscreen(){document.getElementById("output").hidden=!0,Module.requestFullscreen(!0,!0)}function update_num_particles_uniforms(){Module.cwrap("set_custom_uniform","number",["number","number","number","number"])(2,NUM_PARTICLES,0,0,sdf2_r),Module.cwrap("set_custom_uniform_feedback","number",["number","number","number","number"])(0,NUM_PARTICLES,0,0,0)}function update_num_particles(){Module.cwrap("set_number_particles","number",["number"])(NUM_PARTICLES),update_num_particles_uniforms()}function set_render(e){Module.cwrap("set_render_mode","number",["number"])(this.selectedIndex),render_mode=this.selectedIndex,update_num_particles_uniforms()}function set_sdf1(e){sdf1=this.selectedIndex,update_conf()}function set_sdf2(e){sdf2=this.selectedIndex,update_conf()}function set_sdfop(e){sdfop=this.selectedIndex,update_conf()}function set_sdf1r(e){sdf1_r=e/100,update_sdf1()}function set_sdf2r(e){sdf2_r=e/100,update_sdf2()}function set_sdf1x(e){sdf1_pos_x=(e-50)/100*4,update_sdf1()}function set_sdf1y(e){sdf1_pos_y=(e-50)/100*4,update_sdf1()}function set_sdf1z(e){sdf1_pos_z=(e-50)/100*4,update_sdf1()}function set_quality(e){var t=this.selectedIndex;quality=1;1==t&&(quality=3),2==t&&(quality=5),NUM_PARTICLES=15*quality*(15*quality)*(15*quality)*6*3,Module.cwrap("set_number_particles","number",["number"])(NUM_PARTICLES),update_conf()}function init_custom_uniforms(){update_num_particles(),update_sdf1(),update_sdf2(),update_conf()}function init_vshader(){var e=document.getElementById("shader-vertex").innerHTML,t=document.getElementById("shader-feedback").innerHTML;Module.cwrap("init_shader","number",["string","number","string","number"])(e,e.length,t,t.length)}var statusElement=document.getElementById("status"),progressElement=document.getElementById("progress"),spinnerElement=document.getElementById("spinner"),waitingtext="",Module={preRun:[],postRun:[],print:function(){var e=document.getElementById("output");return e&&(e.value=""),function(t){arguments.length>1&&(t=Array.prototype.slice.call(arguments).join(" ")),console.log(t),e&&(e.value+=t+"\n",e.scrollTop=e.scrollHeight)}}(),printErr:function(e){arguments.length>1&&(e=Array.prototype.slice.call(arguments).join(" ")),console.error(e)},canvas:(canvas.addEventListener("webglcontextlost",(function(e){alert("WebGL context lost. You will need to reload the page."),e.preventDefault()}),!1),canvas),setStatus:function(e){if(Module.setStatus.last||(Module.setStatus.last={time:Date.now(),text:""}),e!==Module.setStatus.text){var t=e.match(/([^(]+)\((\d+(\.\d+)?)\/(\d+)\)/),n=Date.now();t&&n-Date.now()<30||(t?(e=t[1],progressElement.value=100*parseInt(t[2]),progressElement.max=100*parseInt(t[4]),progressElement.style.visibility="visible",spinnerElement.hidden=!1):(progressElement.value=null,progressElement.max=null,progressElement.style.visibility="hidden",e||(waitingtext=" waiting...")),statusElement.innerHTML=e+waitingtext)}},totalDependencies:0,monitorRunDependencies:function(e){this.totalDependencies=Math.max(this.totalDependencies,e),Module.setStatus(e?"Preparing... ("+(this.totalDependencies-e)+"/"+this.totalDependencies+")":"All downloads complete.")}};Module.setStatus("Downloading..."),window.onerror=function(){Module.setStatus("Exception thrown, see JavaScript console"),spinnerElement.style.display="none",Module.setStatus=function(e){e&&Module.printErr("[post-exception status] "+e)}}</script><script async src=feedback_advanced.js></script></body></html>
